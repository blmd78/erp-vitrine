import { readFileSync, writeFileSync, readdirSync, existsSync, mkdirSync, statSync, } from 'node:fs';
import { join, extname, basename, dirname, relative, resolve } from 'node:path';
import { createHash } from 'node:crypto';
import { smartArrayUnionType } from './inference.js';
import { typeLogger } from '../utils/logger.js';
let hasGeneratedTypes = false;
/**
 * Main automatic type generation function
 * This is called automatically when config-manager is imported in a user project
 */
export const autoGenerateTypes = async (options = {}) => {
    // Skip if already generated this session (unless forced)
    if (hasGeneratedTypes && !options.force) {
        return true;
    }
    // Detect user project
    const projectRoot = detectUserProject();
    if (!projectRoot) {
        if (!options.silent && process.env.NODE_ENV !== 'test') {
            typeLogger.info('No user project detected', {
                scope: 'auto-generation',
            });
        }
        return false;
    }
    // Get config directory
    const configDir = getConfigDirectory(projectRoot, options.configDir);
    // Determine output path - use provided outputFile or default to types/config.d.ts in project root
    const outputFile = options.outputFile
        ? resolve(projectRoot, options.outputFile)
        : join(projectRoot, 'types', 'config.d.ts');
    const generatedTypesDir = dirname(outputFile);
    const generatedTypesFile = outputFile;
    if (!existsSync(configDir)) {
        throw new Error(`Config directory not found: ${configDir}. Make sure the config directory exists or specify a custom path via configDir option.`);
    }
    // Check if generation is needed
    if (!options.force && !hasConfigChanged(configDir, generatedTypesFile)) {
        if (!options.silent) {
            typeLogger.info('Config types are up to date', {
                scope: 'cache-check',
            });
        }
        hasGeneratedTypes = true;
        return true;
    }
    // Create generated types directory
    mkdirSync(generatedTypesDir, { recursive: true });
    await generateTypes(configDir, generatedTypesFile, projectRoot, options.silent);
    hasGeneratedTypes = true;
    return true;
};
/**
 * Reset generation state (useful for testing)
 */
export const resetAutoGeneration = () => {
    hasGeneratedTypes = false;
};
/**
 * Generate TypeScript declaration from JSON config files
 */
export const generateConfigTypes = (configDir) => {
    if (!existsSync(configDir)) {
        throw new Error(`Config directory not found: ${configDir}`);
    }
    // Files to exclude from type generation (used for error testing)
    const excludedFiles = ['invalid.json'];
    const files = readdirSync(configDir)
        .filter(file => extname(file) === '.json')
        .filter(file => !excludedFiles.includes(file));
    if (files.length === 0) {
        throw new Error(`No JSON config files found in: ${configDir}`);
    }
    const configs = {};
    // Load all config files
    files.forEach(file => {
        const filePath = join(configDir, file);
        const configName = basename(file, '.json');
        const content = readFileSync(filePath, 'utf-8');
        configs[configName] = JSON.parse(content);
    });
    // Validate consistency between environments
    validateConfigConsistency(configs);
    // Generate merged type structure
    const typeDefinition = mergeJsonTypes(configs);
    // Generate the Prisma-style type declaration
    return `/**
 * Auto-generated type definitions from JSON configuration files
 * Generated from: ${configDir}
 * DO NOT EDIT MANUALLY - This file is automatically generated
 */

// Export direct du schema généré (Prisma-style)
export interface GeneratedConfigSchema ${typeDefinition}

// Module augmentation pour remplacer ConfigSchema
declare module '@nextnode/config-manager' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface ConfigSchema extends GeneratedConfigSchema {}
}

export {}
`;
};
/**
 * Collect all possible values for each property path across all configs
 */
const collectAllValues = (configs, currentPath = '', allValues = new Map()) => {
    const configValues = Object.values(configs).filter(config => config !== null &&
        typeof config === 'object' &&
        !Array.isArray(config));
    if (configValues.length === 0)
        return allValues;
    // Get all possible keys from all configs
    const allKeys = new Set();
    configValues.forEach(config => {
        Object.keys(config).forEach(key => allKeys.add(key));
    });
    allKeys.forEach(key => {
        const fullPath = currentPath ? `${currentPath}.${key}` : key;
        const valuesForKey = new Set();
        configValues.forEach(config => {
            if (config[key] !== undefined) {
                const value = config[key];
                if (typeof value === 'object' &&
                    value !== null &&
                    !Array.isArray(value)) {
                    // Recursively collect for nested objects
                    const nestedConfigs = {};
                    Object.entries(configs).forEach(([env, envConfig]) => {
                        if (envConfig &&
                            typeof envConfig === 'object' &&
                            !Array.isArray(envConfig) &&
                            envConfig[key]) {
                            nestedConfigs[env] = envConfig[key];
                        }
                    });
                    collectAllValues(nestedConfigs, fullPath, allValues);
                }
                else {
                    valuesForKey.add(value);
                }
            }
        });
        if (valuesForKey.size > 0) {
            allValues.set(fullPath, valuesForKey);
        }
    });
    return allValues;
};
/**
 * Create TypeScript type from collected values with union types for multiple values
 */
const createUnionType = (values) => {
    if (values.size === 0)
        return 'unknown';
    if (values.size === 1) {
        const value = Array.from(values)[0];
        if (value === null)
            return 'null';
        if (typeof value === 'string')
            return `'${value.replace(/'/g, "\\'")}'`;
        if (typeof value === 'number')
            return value.toString();
        if (typeof value === 'boolean')
            return value.toString();
        if (Array.isArray(value)) {
            const uniqueTypes = new Set();
            value.forEach(item => {
                if (typeof item === 'string')
                    uniqueTypes.add(`'${item.replace(/'/g, "\\'")}'`);
                else if (typeof item === 'number')
                    uniqueTypes.add(item.toString());
                else if (typeof item === 'boolean')
                    uniqueTypes.add(item.toString());
                else if (item === null)
                    uniqueTypes.add('null');
                else
                    uniqueTypes.add('unknown');
            });
            const elementType = Array.from(uniqueTypes).join(' | ');
            return `readonly (${elementType})[]`;
        }
        return 'unknown';
    }
    // Si toutes les valeurs sont des arrays, utilise le smart array typing
    if (Array.from(values).every(v => Array.isArray(v))) {
        return smartArrayUnionType(Array.from(values));
    }
    // Sinon union normale
    const types = Array.from(values).map(value => {
        if (value === null)
            return 'null';
        if (typeof value === 'string')
            return `'${value.replace(/'/g, "\\'")}'`;
        if (typeof value === 'number')
            return value.toString();
        if (typeof value === 'boolean')
            return value.toString();
        if (Array.isArray(value))
            return 'readonly string[]';
        return 'unknown';
    });
    return types.join(' | ');
};
/**
 * Generate merged structure with union types
 */
const generateMergedStructure = (configs, allValues, currentPath = '', depth = 0) => {
    const indent = '  '.repeat(depth);
    const configValues = Object.values(configs).filter(config => config !== null &&
        typeof config === 'object' &&
        !Array.isArray(config));
    if (configValues.length === 0)
        return 'Record<string, unknown>';
    // Get all possible keys from all configs
    const allKeys = new Set();
    configValues.forEach(config => {
        Object.keys(config).forEach(key => allKeys.add(key));
    });
    const properties = Array.from(allKeys).map(key => {
        const fullPath = currentPath ? `${currentPath}.${key}` : key;
        // Check if this path has collected values (primitive types)
        if (allValues.has(fullPath)) {
            const values = allValues.get(fullPath);
            const unionType = createUnionType(values);
            return `${indent}  readonly ${key}: ${unionType}`;
        }
        // This must be a nested object - recurse
        const nestedConfigs = {};
        Object.entries(configs).forEach(([env, envConfig]) => {
            if (envConfig &&
                typeof envConfig === 'object' &&
                !Array.isArray(envConfig) &&
                envConfig[key] &&
                typeof envConfig[key] ===
                    'object' &&
                !Array.isArray(envConfig[key])) {
                nestedConfigs[env] = envConfig[key];
            }
        });
        if (Object.keys(nestedConfigs).length > 0) {
            const nestedType = generateMergedStructure(nestedConfigs, allValues, fullPath, depth + 1);
            return `${indent}  readonly ${key}: ${nestedType}`;
        }
        return `${indent}  readonly ${key}: unknown`;
    });
    return `{\n${properties.join('\n')}\n${indent}}`;
};
/**
 * Merge multiple JSON objects and infer their combined type with union types
 */
const mergeJsonTypes = (configs) => {
    // Collect all possible values for each property path
    const allValues = collectAllValues(configs);
    // Generate the structure with union types
    return generateMergedStructure(configs, allValues);
};
/**
 * Simple validation to ensure all configs have consistent structure
 * Note: 'default' is excluded as it's the base merged with all environments
 */
const validateConfigConsistency = (configs) => {
    const environments = Object.keys(configs).filter(env => env !== 'default' && // Exclude default - it's the base for all environments
        configs[env] !== null &&
        typeof configs[env] === 'object');
    if (environments.length < 2)
        return; // No validation needed for single environment
    // Get all property paths from all environments
    const getAllPaths = (obj, prefix = '') => {
        const paths = new Set();
        if (!obj || typeof obj !== 'object' || Array.isArray(obj))
            return paths;
        const record = obj;
        Object.keys(record).forEach(key => {
            const fullPath = prefix ? `${prefix}.${key}` : key;
            paths.add(fullPath);
            if (typeof record[key] === 'object' &&
                record[key] !== null &&
                !Array.isArray(record[key])) {
                getAllPaths(record[key], fullPath).forEach(path => paths.add(path));
            }
        });
        return paths;
    };
    // Collect all paths from all environments
    const allPaths = new Map(); // path -> Set of environments that have it
    environments.forEach(env => {
        const paths = getAllPaths(configs[env]);
        paths.forEach(path => {
            if (!allPaths.has(path))
                allPaths.set(path, new Set());
            allPaths.get(path).add(env);
        });
    });
    // Check for inconsistencies
    const errors = [];
    allPaths.forEach((envsWithPath, path) => {
        const missingEnvs = environments.filter(env => !envsWithPath.has(env));
        if (missingEnvs.length > 0) {
            const hasEnvs = Array.from(envsWithPath);
            errors.push(`Property '${path}' exists in [${hasEnvs.join(', ')}] but missing in [${missingEnvs.join(', ')}]`);
        }
    });
    if (errors.length > 0) {
        throw new Error(`❌ Configuration consistency validation failed:\n\n${errors.join('\n')}\n\nAll environments must have the same structure.`);
    }
};
/**
 * Detect if we're running in a user project by checking for a config directory
 */
const detectUserProject = () => {
    const currentDir = process.cwd();
    // Check if we're in the config-manager package itself
    const packageJsonPath = join(currentDir, 'package.json');
    if (existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
        if (packageJson.name === '@nextnode/config-manager') {
            // We're in the config-manager package itself, don't auto-generate
            return null;
        }
    }
    const configPath = join(currentDir, 'config');
    if (existsSync(configPath) && statSync(configPath).isDirectory()) {
        return currentDir;
    }
    return null;
};
/**
 * Get the config directory path (always config/ at project root)
 */
const getConfigDirectory = (projectRoot, customConfigDir) => {
    if (customConfigDir) {
        return join(projectRoot, customConfigDir);
    }
    return join(projectRoot, 'config');
};
/**
 * Calculate hash of all config files content for change detection
 */
const getConfigHash = (configDir) => {
    const files = readdirSync(configDir)
        .filter(file => file.endsWith('.json'))
        .sort();
    let combinedContent = '';
    for (const file of files) {
        const filePath = join(configDir, file);
        combinedContent += readFileSync(filePath, 'utf-8');
    }
    return createHash('md5').update(combinedContent).digest('hex');
};
/**
 * Check if config files have changed since last generation
 */
const hasConfigChanged = (configDir, outputFile) => {
    if (!existsSync(outputFile))
        return true;
    // Read the hash from the generated file header
    const generatedContent = readFileSync(outputFile, 'utf-8');
    const hashMatch = generatedContent.match(/Generated hash: ([a-f0-9]{32})/);
    if (!hashMatch)
        return true;
    const oldHash = hashMatch[1];
    const newHash = getConfigHash(configDir);
    return oldHash !== newHash;
};
/**
 * Validate that the output path is safe (no path traversal)
 */
const validateOutputPath = (outputFile, projectRoot) => {
    const resolvedOutput = resolve(outputFile);
    const resolvedProject = resolve(projectRoot);
    const relativePath = relative(resolvedProject, resolvedOutput);
    // Check if the path tries to escape the project directory
    return !relativePath.startsWith('..');
};
/**
 * Generate types using our existing generator
 */
const generateTypes = async (configDir, outputFile, projectRoot, silent = false) => {
    // Validate output path for security
    if (!validateOutputPath(outputFile, projectRoot)) {
        throw new Error(`Invalid output path: ${outputFile}. Path traversal detected.`);
    }
    // Ensure types directory exists
    const typesDir = dirname(outputFile);
    if (!existsSync(typesDir)) {
        mkdirSync(typesDir, { recursive: true });
    }
    // Generate type content
    const typeContent = generateConfigTypes(configDir);
    // Add hash to the generated content for change detection
    const configHash = getConfigHash(configDir);
    const contentWithHash = typeContent.replace('* DO NOT EDIT MANUALLY - This file is automatically generated', `* DO NOT EDIT MANUALLY - This file is automatically generated\n * Generated hash: ${configHash}`);
    writeFileSync(outputFile, contentWithHash);
    // Create relative paths from project root
    const relativeOutputFile = relative(projectRoot, outputFile);
    const relativeConfigDir = relative(projectRoot, configDir);
    if (!silent) {
        typeLogger.info(`Generated types: ${relativeOutputFile} (from ${relativeConfigDir})`, {
            scope: 'type-generation',
        });
    }
};
//# sourceMappingURL=generator.js.map