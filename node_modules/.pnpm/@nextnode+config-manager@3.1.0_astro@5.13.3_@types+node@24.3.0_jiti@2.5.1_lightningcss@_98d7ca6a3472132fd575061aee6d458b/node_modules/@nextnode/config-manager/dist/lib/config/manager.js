import { getNestedValue } from '../utils/helpers.js';
import { resolveEnvironment } from '../utils/validation.js';
import { autoGenerateTypes } from '../types/generator.js';
import { ConfigurationPathError } from '../definitions/errors.js';
import { ConfigLoader } from './loader.js';
// Global configuration loader instance
let globalLoader = null;
/**
 * Ensure global loader is initialized with default options if not already present
 */
const ensureGlobalLoader = () => {
    if (!globalLoader) {
        globalLoader = new ConfigLoader();
    }
    return globalLoader;
};
/**
 * Initialize the configuration system with optional type override
 *
 * @param options - Configuration options
 *
 * @example
 * ```typescript
 * // Basic initialization (uses automatic type detection)
 * initConfig({ configDir: './config' })
 *
 * // With explicit type override (optional)
 * initConfig<MyProjectConfigType>({ configDir: './config' })
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const initConfig = async (options = {}) => {
    globalLoader = new ConfigLoader(options);
    // Automatically generate types for the user project (mandatory)
    await autoGenerateTypes(options.configDir ? { configDir: options.configDir } : {});
};
export function getConfig(path, environment) {
    const loader = ensureGlobalLoader();
    const resolvedEnv = resolveEnvironment(environment);
    const config = loader.loadConfig(resolvedEnv);
    // Return entire config if no path specified (deeply readonly)
    if (!path) {
        return config;
    }
    // Get nested value using dot notation
    const value = getNestedValue(config, path);
    if (value === undefined) {
        throw new ConfigurationPathError(path, resolvedEnv, loader.getConfigDirectory?.());
    }
    return value;
}
export function hasConfig(path, environment) {
    const loader = ensureGlobalLoader();
    const config = loader.loadConfig(resolveEnvironment(environment));
    const value = getNestedValue(config, path);
    return value !== undefined;
}
/**
 * Get current environment name
 */
export const getEnvironment = () => resolveEnvironment();
/**
 * Clear configuration cache (useful for testing or hot reloading)
 */
export const clearConfigCache = () => {
    if (globalLoader) {
        globalLoader.clearCache();
    }
};
/**
 * Get all available configuration environments
 */
export const getAvailableEnvironments = () => {
    const loader = ensureGlobalLoader();
    return loader.getAvailableConfigs();
};
/**
 * Validate that required configuration paths exist with automatic type inference
 */
export const validateRequiredConfig = (requiredPaths, environment) => {
    const resolvedEnv = resolveEnvironment(environment);
    const missing = [];
    for (const path of requiredPaths) {
        if (!hasConfig(path, resolvedEnv)) {
            missing.push(path);
        }
    }
    return {
        valid: missing.length === 0,
        missing,
    };
};
//# sourceMappingURL=manager.js.map