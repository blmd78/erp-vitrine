/**
 * React hook for optimized images with responsive srcset and sizes
 */
import { useMemo } from 'react';
import { DEFAULT_BREAKPOINTS, DEFAULT_DENSITIES, generateSizes, generateSrcSet, } from '../utils/index.js';
// Re-export COMMON_SIZES for convenience
export { COMMON_SIZES } from '../utils/index.js';
/**
 * Hook for optimized image with responsive srcset
 *
 * @example
 * ```tsx
 * const image = useOptimizedImage({
 *   src: '/image.jpg',
 *   width: 800,
 *   height: 600
 * }, {
 *   sizes: COMMON_SIZES.halfDesktop,
 *   loading: 'lazy'
 * })
 *
 * <img {...image} alt="Description" />
 * ```
 */
export function useOptimizedImage(image, options = {}) {
    const images = Array.isArray(image) ? image : [image];
    const primaryImage = images[0];
    if (!primaryImage) {
        throw new Error('At least one image is required');
    }
    const { breakpoints = DEFAULT_BREAKPOINTS, densities = DEFAULT_DENSITIES, loading = 'lazy', fetchPriority, lqip, } = options;
    // Generate srcset for responsive images
    const srcSet = useMemo(() => {
        if (images.length === 1) {
            // Single image - generate density-based srcset if needed
            if (densities.length > 1) {
                return images
                    .map((img, idx) => `${img.src} ${densities[idx]}x`)
                    .join(', ');
            }
            return undefined;
        }
        // Multiple images - width-based srcset
        return generateSrcSet(images);
    }, [images, densities]);
    // Generate sizes attribute
    const sizesAttr = useMemo(() => {
        if (!srcSet)
            return undefined;
        // If custom sizes provided, use it
        if (options.sizes) {
            return options.sizes;
        }
        // Generate default sizes based on breakpoints
        const sizeEntries = breakpoints.map((bp, idx) => ({
            breakpoint: bp,
            size: idx === 0 ? '100vw' : `${Math.floor(100 / (idx + 1))}vw`,
        }));
        return generateSizes(sizeEntries);
    }, [srcSet, breakpoints, options.sizes]);
    return {
        src: primaryImage.src,
        srcSet,
        sizes: sizesAttr,
        loading,
        ...(fetchPriority && { fetchPriority }),
        ...(lqip && { lqip }),
        width: primaryImage.width,
        height: primaryImage.height,
        format: primaryImage.format,
    };
}
export function useResponsiveImageVariants(variants) {
    return useMemo(() => variants.map(({ media, images }) => ({
        media,
        srcSet: generateSrcSet(images),
        ...(images[0]?.format && { type: `image/${images[0].format}` }),
    })), [variants]);
}
//# sourceMappingURL=useOptimizedImage.js.map