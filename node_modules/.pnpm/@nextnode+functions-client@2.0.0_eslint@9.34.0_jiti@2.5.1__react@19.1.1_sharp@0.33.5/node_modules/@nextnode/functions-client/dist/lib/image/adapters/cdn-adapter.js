/**
 * CDN image optimization adapter
 * Generates optimized URLs for popular CDN providers
 * Supports Cloudflare Images, Imgix, and generic CDN patterns
 */
import { ImageSecurityError } from '../errors.js';
import { detectImageFormat, getQualityForFormat, mergeLQIPConfig, } from '../utils/index.js';
import { BaseImageAdapter } from './base-adapter.js';
/**
 * CDN image adapter
 * Generates transformation URLs for on-the-fly image optimization
 */
export class CDNImageAdapter extends BaseImageAdapter {
    provider;
    baseUrl;
    accountId;
    defaultProfile;
    constructor(config) {
        super(`CDNImageAdapter(${config.provider})`);
        this.provider = config.provider;
        this.baseUrl = config.baseUrl.replace(/\/$/, ''); // Remove trailing slash
        this.accountId = config.accountId;
        this.defaultProfile = config.defaultProfile || 'balanced';
    }
    async optimize(source, options = {}) {
        // Validate dimensions against security limits
        this.validateDimensions(options.width, options.height);
        const sourceString = this.getSourceString(source);
        // Detect format
        const detectedFormat = detectImageFormat(sourceString);
        const format = options.format || detectedFormat || 'webp';
        // Get quality
        const profile = options.profile || this.defaultProfile;
        const quality = getQualityForFormat(format, profile, options.quality);
        // Build CDN URL based on provider
        const url = this.buildCDNUrl(sourceString, {
            format,
            quality,
            ...(options.width && { width: options.width }),
            ...(options.height && { height: options.height }),
        });
        // Return optimized image (dimensions are estimates)
        return {
            src: url,
            width: options.width || 0,
            height: options.height || 0,
            format,
        };
    }
    async generateLQIP(source, config = {}) {
        const sourceString = this.getSourceString(source);
        const lqipConfig = mergeLQIPConfig(config);
        // Build LQIP URL
        const url = this.buildCDNUrl(sourceString, {
            format: lqipConfig.format,
            quality: lqipConfig.quality,
            width: lqipConfig.width,
            height: lqipConfig.height,
        });
        return url;
    }
    supportsFormat(format) {
        // Most CDNs support all major formats
        return ['png', 'webp', 'avif', 'jpeg', 'jpg'].includes(format.toLowerCase());
    }
    /**
     * Sanitize and validate image source URL to prevent injection attacks
     * Prevents: path traversal, protocol injection, malicious URLs
     */
    sanitizeSource(source) {
        // Block path traversal attempts
        if (source.includes('../') || source.includes('..\\')) {
            throw new ImageSecurityError('Path traversal detected in image source', {
                source,
                reason: 'directory_traversal',
            });
        }
        // Block absolute paths (should be relative to CDN base)
        if (source.startsWith('/')) {
            throw new ImageSecurityError('Absolute paths not allowed, use relative paths', {
                source,
                reason: 'absolute_path',
            });
        }
        // Validate it looks like an image path (basic extension check)
        const validExtensions = /\.(jpg|jpeg|png|webp|avif|gif|svg)$/i;
        if (!validExtensions.test(source)) {
            throw new ImageSecurityError('Invalid image source: must have valid image extension', { source, reason: 'invalid_extension' });
        }
        // Encode URI components to prevent injection
        return encodeURIComponent(source);
    }
    /**
     * Get URL builder configuration for current provider
     */
    getURLBuilderConfig() {
        switch (this.provider) {
            case 'cloudflare':
                return {
                    formatKey: 'format=',
                    qualityKey: 'quality=',
                    widthKey: 'width=',
                    heightKey: 'height=',
                    useQueryParams: false,
                    pathTemplate: '/cdn-cgi/image/{params}/{source}',
                    separator: ',',
                };
            case 'imgix':
                return {
                    formatKey: 'fm',
                    qualityKey: 'q',
                    widthKey: 'w',
                    heightKey: 'h',
                    useQueryParams: true,
                    additionalParams: { auto: 'compress,format' },
                };
            case 'cloudinary':
                return {
                    formatKey: 'f_',
                    qualityKey: 'q_',
                    widthKey: 'w_',
                    heightKey: 'h_',
                    useQueryParams: false,
                    pathTemplate: '/image/upload/{params}/{source}',
                    separator: ',',
                };
            default:
                return {
                    formatKey: 'format',
                    qualityKey: 'quality',
                    widthKey: 'width',
                    heightKey: 'height',
                    useQueryParams: true,
                };
        }
    }
    /**
     * Build CDN transformation URL using unified logic
     */
    buildCDNUrl(source, params) {
        const safeSource = this.sanitizeSource(source);
        const config = this.getURLBuilderConfig();
        if (config.useQueryParams) {
            return this.buildQueryParamURL(safeSource, params, config);
        }
        return this.buildPathBasedURL(safeSource, params, config);
    }
    /**
     * Build URL with query parameters (Imgix, Generic)
     */
    buildQueryParamURL(source, params, config) {
        const searchParams = new URLSearchParams();
        searchParams.set(config.formatKey, params.format);
        searchParams.set(config.qualityKey, params.quality.toString());
        if (config.additionalParams) {
            for (const [key, value] of Object.entries(config.additionalParams)) {
                searchParams.set(key, value);
            }
        }
        if (params.width) {
            searchParams.set(config.widthKey, params.width.toString());
        }
        if (params.height) {
            searchParams.set(config.heightKey, params.height.toString());
        }
        return `${this.baseUrl}/${source}?${searchParams.toString()}`;
    }
    /**
     * Build URL with path-based transformations (Cloudflare, Cloudinary)
     */
    buildPathBasedURL(source, params, config) {
        const transformations = [
            `${config.formatKey}${params.format}`,
            `${config.qualityKey}${params.quality}`,
        ];
        if (params.width) {
            transformations.push(`${config.widthKey}${params.width}`);
        }
        if (params.height) {
            transformations.push(`${config.heightKey}${params.height}`);
        }
        const paramsString = transformations.join(config.separator || ',');
        if (config.pathTemplate) {
            return `${this.baseUrl}${config.pathTemplate
                .replace('{params}', paramsString)
                .replace('{source}', source)}`;
        }
        return `${this.baseUrl}/${paramsString}/${source}`;
    }
}
//# sourceMappingURL=cdn-adapter.js.map