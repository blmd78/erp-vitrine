/**
 * LQIP (Low Quality Image Placeholder) generation utilities
 * Implements 2025 best practices for blur placeholders
 */
/**
 * Default LQIP configuration
 * - 20x20px dimensions (5-10 KB)
 * - Quality 10 (heavily compressed)
 * - Blur 10 (CSS blur filter)
 * - WebP format (better compression)
 */
export const DEFAULT_LQIP_CONFIG = {
    enabled: true,
    width: 20,
    height: 20,
    quality: 10,
    blur: 10,
    format: 'webp',
};
/**
 * Calculate LQIP dimensions maintaining aspect ratio
 */
export function calculateLQIPDimensions(originalWidth, originalHeight, maxDimension = 20) {
    const aspectRatio = originalWidth / originalHeight;
    if (originalWidth > originalHeight) {
        return {
            width: maxDimension,
            height: Math.round(maxDimension / aspectRatio),
        };
    }
    return {
        width: Math.round(maxDimension * aspectRatio),
        height: maxDimension,
    };
}
/**
 * Encode buffer to Base64 data URI
 */
export function encodeToDataURI(buffer, format) {
    const base64 = buffer.toString('base64');
    const mimeType = format === 'webp' ? 'image/webp' : 'image/jpeg';
    return `data:${mimeType};base64,${base64}`;
}
/**
 * Generate CSS blur filter value
 */
export function getBlurFilterCSS(blurAmount) {
    return `blur(${blurAmount}px)`;
}
/**
 * Generate inline styles for LQIP
 * Includes blur filter and smooth transition
 */
export function getLQIPStyles(config) {
    return {
        filter: getBlurFilterCSS(config.blur),
        transition: 'filter 0.3s ease-in-out',
        willChange: 'filter',
    };
}
/**
 * Generate CSS-only LQIP integer encoding (2025 technique)
 * Packs color data into a single integer for minimal payload
 *
 * This is an advanced technique that encodes dominant colors
 * into an integer that can be decoded purely with CSS
 *
 * @experimental
 */
export function encodeLQIPInteger(colors) {
    // Pack RGB into 24-bit integer
    // Format: 0xRRGGBB
    return (colors.r << 16) | (colors.g << 8) | colors.b;
}
/**
 * Decode LQIP integer back to RGB
 *
 * @experimental
 */
export function decodeLQIPInteger(encoded) {
    return {
        r: (encoded >> 16) & 0xff,
        g: (encoded >> 8) & 0xff,
        b: encoded & 0xff,
    };
}
/**
 * Calculate dominant color from image data (simplified)
 * In production, this should use a proper color extraction algorithm
 *
 * @param imageData RGB pixel data
 * @returns Dominant color as RGB object
 */
export function calculateDominantColor(imageData) {
    let r = 0;
    let g = 0;
    let b = 0;
    const pixelCount = imageData.length / 4;
    // Calculate average color (simple dominant color approximation)
    for (let i = 0; i < imageData.length; i += 4) {
        const red = imageData[i];
        const green = imageData[i + 1];
        const blue = imageData[i + 2];
        if (red !== undefined && green !== undefined && blue !== undefined) {
            r += red;
            g += green;
            b += blue;
        }
    }
    return {
        r: Math.round(r / pixelCount),
        g: Math.round(g / pixelCount),
        b: Math.round(b / pixelCount),
    };
}
/**
 * Merge custom LQIP config with defaults
 */
export function mergeLQIPConfig(custom) {
    return {
        ...DEFAULT_LQIP_CONFIG,
        ...custom,
    };
}
/**
 * Validate data URI to prevent javascript: and malicious data: URIs
 * @throws {Error} If URI is invalid or potentially dangerous
 */
function validateDataURI(uri) {
    // Block javascript: protocol
    if (/^javascript:/i.test(uri)) {
        throw new Error('Invalid data URI: javascript: protocol not allowed');
    }
    // Block data URIs that aren't images
    if (/^data:(?!image\/)/i.test(uri)) {
        throw new Error('Invalid data URI: only data:image/* MIME types allowed');
    }
    // Only allow data:image/* URIs or https:/http: URLs
    if (!/^data:image\//i.test(uri) && !/^https?:\/\//i.test(uri)) {
        throw new Error('Invalid URI: only data:image/*, https://, or http:// URLs allowed');
    }
    return uri;
}
/**
 * Generate LQIP placeholder HTML element using DOM API (XSS-safe)
 * Replaces string concatenation with secure DOM element creation
 * @throws {Error} If dataURI is invalid or potentially dangerous
 */
export function generateLQIPElement(dataURI, alt, config) {
    // Validate URI before use to prevent XSS
    const safeURI = validateDataURI(dataURI);
    const img = document.createElement('img');
    img.src = safeURI;
    img.alt = alt;
    img.className = 'lqip-placeholder';
    img.loading = 'lazy';
    const styles = getLQIPStyles(config);
    Object.entries(styles).forEach(([key, value]) => {
        img.style.setProperty(key, value);
    });
    return img;
}
/**
 * CSS classes for LQIP implementation
 * Use these with your CSS framework
 */
export const LQIP_CSS_CLASSES = {
    /** Placeholder image (blurred) */
    placeholder: 'lqip-placeholder',
    /** Container that holds both placeholder and full image */
    container: 'lqip-container',
    /** Full quality image (initially hidden) */
    fullImage: 'lqip-full',
    /** State class when full image is loaded */
    loaded: 'lqip-loaded',
};
/**
 * Generate complete LQIP CSS
 * Includes smooth transition from blur to sharp
 */
export function generateLQIPCSS() {
    return `
.${LQIP_CSS_CLASSES.container} {
  position: relative;
  overflow: hidden;
}

.${LQIP_CSS_CLASSES.placeholder} {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  filter: blur(10px);
  transition: opacity 0.3s ease-in-out;
}

.${LQIP_CSS_CLASSES.fullImage} {
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.${LQIP_CSS_CLASSES.container}.${LQIP_CSS_CLASSES.loaded} .${LQIP_CSS_CLASSES.placeholder} {
  opacity: 0;
}

.${LQIP_CSS_CLASSES.container}.${LQIP_CSS_CLASSES.loaded} .${LQIP_CSS_CLASSES.fullImage} {
  opacity: 1;
}
`.trim();
}
//# sourceMappingURL=lqip.js.map