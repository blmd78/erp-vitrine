/**
 * Base adapter interface for image optimization
 * Allows different platforms (Astro, Next.js, CDN) to implement their own optimization logic
 */
import { createLogger } from '@nextnode/logger';
import { ImageProcessingError, ImageValidationError } from '../errors.js';
import { SECURITY_LIMITS } from '../types.js';
/**
 * Abstract base adapter with common functionality
 */
export class BaseImageAdapter {
    adapterName;
    logger;
    constructor(adapterName) {
        this.adapterName = adapterName;
        this.logger = createLogger({
            prefix: `image:${adapterName}`,
        });
    }
    /**
     * Default batch optimization implementation
     * Uses Promise.allSettled for parallel processing with error handling
     */
    async optimizeBatch(sources, options) {
        const results = await Promise.allSettled(sources.map(source => this.optimize(source, options)));
        const successful = [];
        const failed = [];
        results.forEach((result, index) => {
            const input = sources[index];
            if (!input)
                return;
            if (result.status === 'fulfilled') {
                successful.push({ input, output: result.value });
            }
            else {
                failed.push({
                    input,
                    error: result.reason?.message || 'Unknown error',
                });
            }
        });
        return { successful, failed };
    }
    getName() {
        return this.adapterName;
    }
    /**
     * Helper to extract source string from ImageSource
     */
    getSourceString(source) {
        if (typeof source === 'string') {
            return source;
        }
        if (Buffer.isBuffer(source)) {
            throw new ImageProcessingError('Buffer sources must be handled by adapter implementation', { sourceType: 'buffer' });
        }
        return source.src;
    }
    /**
     * Helper to log adapter operations
     */
    log(message, data) {
        this.logger.info(message, data);
    }
    /**
     * Helper to handle errors consistently
     */
    handleError(operation, error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return new Error(`[${this.adapterName}] ${operation} failed: ${message}`);
    }
    /**
     * Validate image dimensions against security limits
     * Prevents DoS attacks through oversized image requests
     */
    validateDimensions(width, height) {
        if (width !== undefined && width > SECURITY_LIMITS.MAX_WIDTH) {
            throw new ImageValidationError(`Image width ${width}px exceeds maximum allowed: ${SECURITY_LIMITS.MAX_WIDTH}px`, {
                width,
                maxWidth: SECURITY_LIMITS.MAX_WIDTH,
                reason: 'width_exceeded',
            });
        }
        if (height !== undefined && height > SECURITY_LIMITS.MAX_HEIGHT) {
            throw new ImageValidationError(`Image height ${height}px exceeds maximum allowed: ${SECURITY_LIMITS.MAX_HEIGHT}px`, {
                height,
                maxHeight: SECURITY_LIMITS.MAX_HEIGHT,
                reason: 'height_exceeded',
            });
        }
        if (width !== undefined &&
            height !== undefined &&
            width * height > SECURITY_LIMITS.MAX_PIXELS) {
            throw new ImageValidationError(`Image dimensions ${width}x${height} (${width * height} pixels) exceed maximum allowed: ${SECURITY_LIMITS.MAX_PIXELS} pixels`, {
                width,
                height,
                pixels: width * height,
                maxPixels: SECURITY_LIMITS.MAX_PIXELS,
                reason: 'pixels_exceeded',
            });
        }
    }
}
//# sourceMappingURL=base-adapter.js.map