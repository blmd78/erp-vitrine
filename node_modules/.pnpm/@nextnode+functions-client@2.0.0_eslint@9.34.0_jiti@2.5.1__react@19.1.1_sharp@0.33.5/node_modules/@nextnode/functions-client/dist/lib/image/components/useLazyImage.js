/**
 * React hook for lazy loading images with IntersectionObserver
 * Implements progressive loading with blur-to-sharp transition
 */
import { useCallback, useEffect, useRef, useState } from 'react';
/**
 * Hook for lazy loading images with IntersectionObserver
 *
 * @example
 * ```tsx
 * const lazyImage = useLazyImage('/image-full.jpg', {
 *   placeholder: '/image-lqip.jpg',
 *   rootMargin: '50px'
 * })
 *
 * <img
 *   ref={lazyImage.ref}
 *   src={lazyImage.src}
 *   style={lazyImage.style}
 *   alt="Description"
 * />
 * ```
 */
export function useLazyImage(src, options = {}) {
    const { rootMargin = '50px', threshold = 0.01, placeholder, onLoadStart, onLoadComplete, onError, } = options;
    const imgRef = useRef(null);
    const [isLoaded, setIsLoaded] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [currentSrc, setCurrentSrc] = useState(placeholder || src);
    // Stable refs for callbacks to prevent unnecessary re-renders
    const callbacksRef = useRef({ onLoadStart, onLoadComplete, onError });
    callbacksRef.current = { onLoadStart, onLoadComplete, onError };
    const loadImage = useCallback(() => {
        setIsLoading(true);
        setError(null);
        callbacksRef.current.onLoadStart?.();
        const img = globalThis.Image
            ? new globalThis.Image()
            : { onload: null, onerror: null, src: '' };
        img.onload = () => {
            setCurrentSrc(src);
            setIsLoaded(true);
            setIsLoading(false);
            callbacksRef.current.onLoadComplete?.();
        };
        img.onerror = () => {
            const err = new Error(`Failed to load image: ${src}`);
            setError(err);
            setIsLoading(false);
            callbacksRef.current.onError?.(err);
        };
        img.src = src;
        return () => {
            // Cleanup: abort loading if component unmounts
            img.src = '';
        };
    }, [src]);
    useEffect(() => {
        const imgElement = imgRef.current;
        if (!imgElement)
            return;
        let cleanup;
        // If no placeholder, load immediately
        if (!placeholder) {
            cleanup = loadImage();
            return cleanup;
        }
        // Create IntersectionObserver
        const observer = new IntersectionObserver(entries => {
            for (const entry of entries) {
                if (entry.isIntersecting) {
                    cleanup = loadImage();
                    observer.disconnect();
                    break;
                }
            }
        }, {
            rootMargin,
            threshold,
        });
        observer.observe(imgElement);
        return () => {
            observer.disconnect();
            cleanup?.();
        };
    }, [placeholder, rootMargin, threshold, loadImage]);
    // Blur transition styles
    const style = {
        filter: isLoaded ? 'blur(0px)' : placeholder ? 'blur(10px)' : 'none',
        transition: 'filter 0.3s ease-in-out',
        willChange: isLoaded ? 'auto' : 'filter',
    };
    return {
        src: currentSrc,
        isLoaded,
        isLoading,
        error,
        ref: imgRef,
        style,
    };
}
export function useImagePreload(sources) {
    const [loadedCount, setLoadedCount] = useState(0);
    const [errors, setErrors] = useState([]);
    useEffect(() => {
        if (sources.length === 0)
            return;
        const images = sources.map(src => {
            const img = new Image();
            img.onload = () => {
                setLoadedCount(prev => prev + 1);
            };
            img.onerror = () => {
                setErrors(prev => [
                    ...prev,
                    { src, error: new Error(`Failed to preload: ${src}`) },
                ]);
                setLoadedCount(prev => prev + 1); // Count as "processed"
            };
            img.src = src;
            return img;
        });
        return () => {
            // Cleanup - abort loading if component unmounts
            for (const img of images) {
                img.src = '';
            }
        };
    }, [sources]);
    return {
        isPreloaded: loadedCount === sources.length,
        progress: sources.length > 0 ? loadedCount / sources.length : 1,
        errors,
    };
}
export function useBackgroundImage(src, options = {}) {
    const { placeholder, rootMargin = '50px', threshold = 0.01 } = options;
    const divRef = useRef(null);
    const [isLoaded, setIsLoaded] = useState(false);
    const [backgroundImage, setBackgroundImage] = useState(placeholder ? `url(${placeholder})` : 'none');
    useEffect(() => {
        const divElement = divRef.current;
        if (!divElement)
            return;
        const observer = new IntersectionObserver(entries => {
            for (const entry of entries) {
                if (entry.isIntersecting) {
                    const img = new Image();
                    img.onload = () => {
                        setBackgroundImage(`url(${src})`);
                        setIsLoaded(true);
                    };
                    img.src = src;
                    observer.disconnect();
                    break;
                }
            }
        }, { rootMargin, threshold });
        observer.observe(divElement);
        return () => {
            observer.disconnect();
        };
    }, [src, rootMargin, threshold]);
    const style = {
        backgroundImage,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        transition: 'filter 0.3s ease-in-out',
        filter: isLoaded ? 'blur(0px)' : placeholder ? 'blur(10px)' : 'none',
    };
    return {
        style,
        isLoaded,
        ref: divRef,
    };
}
//# sourceMappingURL=useLazyImage.js.map