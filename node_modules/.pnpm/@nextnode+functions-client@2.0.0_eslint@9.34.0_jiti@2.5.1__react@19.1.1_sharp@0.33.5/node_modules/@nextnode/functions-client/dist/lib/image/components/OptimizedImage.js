import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { COMMON_SIZES } from '../utils/index.js';
import { useLazyImage } from './useLazyImage.js';
import { useOptimizedImage } from './useOptimizedImage.js';
/**
 * Optimized Image component with responsive srcset and lazy loading
 *
 * @example
 * ```tsx
 * <OptimizedImage
 *   image={optimizedImages}
 *   alt="Product photo"
 *   sizes={COMMON_SIZES.twoColumns}
 *   loading="lazy"
 *   lqip="/product-lqip.jpg"
 * />
 * ```
 */
export function OptimizedImage({ image, alt, sizes = COMMON_SIZES.fullWidth, loading = 'lazy', fetchPriority, lqip, className, style, onClick, onKeyDown, imgProps, }) {
    // Use optimized image hook for srcset generation
    const optimized = useOptimizedImage(image, {
        sizes,
        loading,
        ...(fetchPriority && { fetchPriority }),
        ...(lqip && { lqip }),
    });
    // Use lazy loading if enabled and placeholder provided
    const lazy = useLazyImage(optimized.src, {
        ...(lqip && { placeholder: lqip }),
        rootMargin: '50px',
    });
    // Combine styles
    const combinedStyle = {
        ...style,
        ...(loading === 'lazy' && lqip ? lazy.style : {}),
    };
    return (_jsx("img", { ref: loading === 'lazy' && lqip ? lazy.ref : undefined, src: loading === 'lazy' && lqip ? lazy.src : optimized.src, srcSet: optimized.srcSet, sizes: optimized.sizes, alt: alt, width: optimized.width, height: optimized.height, loading: loading, 
        // @ts-expect-error - fetchpriority is valid but not in types yet
        fetchpriority: fetchPriority, className: className, style: combinedStyle, onClick: onClick, onKeyDown: onKeyDown, ...imgProps }));
}
export function OptimizedPicture({ sources, fallback, alt, className, style, }) {
    return (_jsxs("picture", { className: className, style: style, children: [sources.map(source => (_jsx("source", { media: source.media, srcSet: source.images
                    .map(img => `${img.src} ${img.width}w`)
                    .join(', '), type: source.images[0]
                    ? `image/${source.images[0].format}`
                    : undefined }, source.media))), _jsx("img", { src: fallback.src, alt: alt, width: fallback.width, height: fallback.height })] }));
}
/**
 * Validate image URL for safe use in CSS
 * @throws {Error} If URL is invalid or potentially dangerous
 */
function validateImageURL(url) {
    // Block javascript: protocol
    if (/^javascript:/i.test(url)) {
        throw new Error('Invalid image URL: javascript: protocol not allowed');
    }
    // Block data URIs that aren't images
    if (/^data:(?!image\/)/i.test(url)) {
        throw new Error('Invalid image URL: only data:image/* allowed');
    }
    // Only allow: data:image/*, https://, http://, or relative paths
    const isValid = /^data:image\//i.test(url) ||
        /^https?:\/\//i.test(url) ||
        /^\//.test(url);
    if (!isValid) {
        throw new Error('Invalid image URL: must be data:image/*, https://, http://, or relative path');
    }
    return url;
}
export function OptimizedBackgroundImage({ image, lqip, children, className, style, }) {
    const lazy = useLazyImage(image.src, {
        ...(lqip && { placeholder: lqip }),
        rootMargin: '100px',
    });
    // Validate URLs before use in CSS to prevent injection
    const safeImageSrc = validateImageURL(lazy.src);
    const combinedStyle = {
        backgroundImage: `url(${safeImageSrc})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        ...style,
        ...(lqip ? lazy.style : {}),
    };
    return (_jsx("div", { ref: lqip ? lazy.ref : undefined, className: className, style: combinedStyle, children: children }));
}
// Export all components
export default OptimizedImage;
//# sourceMappingURL=OptimizedImage.js.map