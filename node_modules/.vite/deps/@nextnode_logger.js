import {
  __publicField
} from "./chunk-Q4XP6UTR.js";

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/core/location.js
var STACK_TRACE_PATTERNS = {
  function: [
    /at\s+([^(\s]+)\s+\(/,
    // at functionName (file:line:col)
    /at\s+(.+?)\s+\(/,
    // at Object.functionName (file:line:col)
    /at\s+([^(\s]+)$/,
    // at functionName
    /at\s+(.+)$/
    // fallback: everything after 'at '
  ],
  file: [
    /\(([^)]+):(\d+):\d+\)/,
    // (file:line:col)
    /at\s+[^(]*\s+([^:\s]+(?:[:\\\\][^:\s]+)*):(\d+):\d+$/,
    // at function file:line:col
    /([^:\s]+(?:[:\\\\][^:\s]+)*):(\d+):\d+$/
    // file:line:col at end
  ]
};
var INTERNAL_FILES = ["logger.ts", "location.ts", "formatters.ts"];
var isValidStackLine = (line) => typeof line === "string" && line.includes("at ") && !line.includes("node_modules");
var isInternalFile = (line) => INTERNAL_FILES.some((file) => line.includes(file));
var extractFunctionName = (stackLine) => {
  for (const pattern of STACK_TRACE_PATTERNS.function) {
    const match = pattern.exec(stackLine);
    if (match == null ? void 0 : match[1]) {
      const functionName = match[1].trim();
      if (functionName.includes("<anonymous>"))
        return "anonymous";
      const lastDotIndex = functionName.lastIndexOf(".");
      if (lastDotIndex !== -1) {
        return functionName.slice(lastDotIndex + 1) || functionName;
      }
      return functionName;
    }
  }
  return "unknown";
};
var extractFileInfo = (stackLine) => {
  for (const pattern of STACK_TRACE_PATTERNS.file) {
    const match = pattern.exec(stackLine);
    if ((match == null ? void 0 : match[1]) && match[2]) {
      const fullPath = match[1];
      const line = Number(match[2]);
      const lastSeparatorIndex = Math.max(fullPath.lastIndexOf("/"), fullPath.lastIndexOf("\\"));
      const file = lastSeparatorIndex !== -1 ? fullPath.slice(lastSeparatorIndex + 1) : fullPath;
      return { file, line };
    }
  }
  return { file: "unknown", line: 0 };
};
var getCallerStackLine = (stack) => {
  const lines = stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (line && isValidStackLine(line) && !isInternalFile(line)) {
      return line;
    }
  }
  return lines[1] || "";
};
var parseLocation = (isProduction) => {
  try {
    const stack = new Error().stack || "";
    const stackLine = getCallerStackLine(stack);
    const functionName = extractFunctionName(stackLine);
    if (isProduction) {
      return { function: functionName };
    }
    const { file, line } = extractFileInfo(stackLine);
    return {
      function: functionName,
      file,
      line
    };
  } catch {
    return isProduction ? { function: "unknown" } : { function: "unknown", file: "unknown", line: 0 };
  }
};
var detectEnvironment = () => {
  const nodeEnv = "development";
  if (nodeEnv === "production" || nodeEnv === "prod") {
    return "production";
  }
  if (nodeEnv === "development" || nodeEnv === "dev") {
    return "development";
  }
  return "development";
};

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/utils/environment.js
var detectRuntime = () => {
  if (typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string") {
    return "node";
  }
  if (typeof importScripts === "function") {
    return "webworker";
  }
  if (typeof window === "object" && typeof document === "object") {
    return "browser";
  }
  return "unknown";
};
var hasCryptoSupport = () => {
  try {
    return !!(crypto && typeof crypto.randomUUID === "function");
  } catch {
    return false;
  }
};

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/utils/crypto.js
var generateRequestId = () => {
  if (hasCryptoSupport()) {
    const uuid = crypto.randomUUID();
    return `req_${uuid.slice(0, 8)}`;
  }
  const runtime = detectRuntime();
  throw new Error(`Web Crypto API not available in ${runtime} environment. Please ensure you're using Node.js v20+ or a modern browser.`);
};

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/utils/time.js
var getCurrentTimestamp = () => (/* @__PURE__ */ new Date()).toISOString();

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/utils/serialization.js
var typeToString = (value) => {
  if (value === null)
    return "null";
  if (value === void 0)
    return "undefined";
  if (typeof value === "function")
    return `[Function: ${value.name || "anonymous"}]`;
  if (typeof value === "symbol")
    return value.toString();
  if (typeof value === "bigint")
    return value.toString();
  return void 0;
};
var safeStringify = (value) => {
  try {
    const primitiveString = typeToString(value);
    if (primitiveString !== void 0)
      return primitiveString;
    if (typeof value === "string")
      return value;
    if (typeof value === "number" || typeof value === "boolean") {
      return String(value);
    }
    const seen = /* @__PURE__ */ new WeakSet();
    const replacer = (_key, val) => {
      if (typeof val !== "object" || val === null) {
        const specialString = typeToString(val);
        return specialString !== void 0 ? specialString : val;
      }
      if (seen.has(val))
        return "[Circular Reference]";
      seen.add(val);
      return val;
    };
    return JSON.stringify(value, replacer, 2);
  } catch (error) {
    return `[Serialization Error: ${error instanceof Error ? error.message : "Unknown error"}]`;
  }
};

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/types.js
var isDevelopmentLocation = (location) => "file" in location && "line" in location;

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/core/formatters.js
var COLORS = {
  reset: "\x1B[0m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  gray: "\x1B[90m"
};
var LOG_LEVEL_COLORS = {
  info: COLORS.blue,
  warn: COLORS.yellow,
  error: COLORS.red
};
var LOG_LEVEL_ICONS = {
  info: "ðŸ”µ",
  warn: "âš ï¸ ",
  error: "ðŸ”´"
};
var SCOPE_COLORS = [
  COLORS.green,
  COLORS.magenta,
  COLORS.cyan,
  COLORS.yellow,
  COLORS.blue
];
var MAX_SCOPE_CACHE_SIZE = 100;
var scopeColorIndex = 0;
var scopeColorMap = /* @__PURE__ */ new Map();
var getScopeColor = (scope) => {
  let color = scopeColorMap.get(scope);
  if (!color) {
    if (scopeColorMap.size >= MAX_SCOPE_CACHE_SIZE) {
      const firstKey = scopeColorMap.keys().next().value;
      if (firstKey)
        scopeColorMap.delete(firstKey);
    }
    color = SCOPE_COLORS[scopeColorIndex % SCOPE_COLORS.length] ?? COLORS.white;
    scopeColorMap.set(scope, color);
    scopeColorIndex = (scopeColorIndex + 1) % SCOPE_COLORS.length;
  }
  return color;
};
var formatTime = (timestamp) => {
  try {
    const date = new Date(timestamp);
    if (Number.isNaN(date.getTime())) {
      return timestamp;
    }
    const hours = date.getUTCHours().toString().padStart(2, "0");
    const minutes = date.getUTCMinutes().toString().padStart(2, "0");
    const seconds = date.getUTCSeconds().toString().padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  } catch {
    return timestamp;
  }
};
var formatLocation = (location) => {
  if (isDevelopmentLocation(location)) {
    return `${location.file}:${location.line}:${location.function}`;
  }
  return location.function;
};
var colorize = (text, color) => `${color}${text}${COLORS.reset}`;
var formatObjectDetails = (object) => {
  const lines = [];
  if (!object)
    return lines;
  if (object.status !== void 0) {
    lines.push(`   â””â”€ status: ${object.status}`);
  }
  if (object.details !== void 0) {
    const detailsStr = safeStringify(object.details);
    if (detailsStr.includes("\n")) {
      lines.push(`   â””â”€ details:`);
      detailsStr.split("\n").forEach((line) => {
        lines.push(`      ${line}`);
      });
    } else {
      lines.push(`   â””â”€ details: ${detailsStr}`);
    }
  }
  return lines;
};
var formatForDevelopment = (entry) => {
  const { level, message, timestamp, location, requestId, scope, object } = entry;
  const components = [];
  components.push(LOG_LEVEL_ICONS[level]);
  components.push(colorize(level.toUpperCase(), LOG_LEVEL_COLORS[level]));
  if (scope) {
    components.push(colorize(`[${scope}]`, getScopeColor(scope)));
  }
  components.push(colorize(`[${formatTime(timestamp)}]`, COLORS.gray));
  components.push(message);
  components.push(colorize(`(${formatLocation(location)}) [${requestId}]`, COLORS.gray));
  const lines = [components.join(" ")];
  lines.push(...formatObjectDetails(object));
  return lines.join("\n");
};
var formatForProduction = (entry) => {
  const { level, message, timestamp, location, requestId, scope, object } = entry;
  const productionEntry = {
    level,
    message,
    timestamp,
    location,
    requestId
  };
  if (scope)
    productionEntry.scope = scope;
  if (object)
    productionEntry.object = object;
  return JSON.stringify(productionEntry);
};
var formatLogEntry = (entry, environment) => environment === "development" ? formatForDevelopment(entry) : formatForProduction(entry);

// node_modules/.pnpm/@nextnode+logger@0.2.3_eslint@9.34.0_jiti@2.5.1_/node_modules/@nextnode/logger/dist/core/logger.js
var CONSOLE_METHODS = {
  info: "log",
  warn: "warn",
  error: "error"
};
var NextNodeLogger = class {
  constructor(config = {}) {
    __publicField(this, "environment");
    __publicField(this, "prefix");
    __publicField(this, "includeLocation");
    this.environment = config.environment ?? detectEnvironment();
    this.prefix = config.prefix;
    this.includeLocation = config.includeLocation ?? true;
  }
  extractScope(object) {
    if (!object) {
      return { scope: void 0, cleanObject: void 0 };
    }
    const { scope, ...rest } = object;
    const hasOtherProperties = Object.keys(rest).length > 0;
    return {
      scope: scope ?? void 0,
      cleanObject: hasOtherProperties ? rest : void 0
    };
  }
  createLogEntry(level, message, object) {
    const { scope, cleanObject } = this.extractScope(object);
    const finalMessage = this.prefix ? `${this.prefix} ${message}` : message;
    return {
      level,
      message: finalMessage,
      timestamp: getCurrentTimestamp(),
      location: this.includeLocation ? parseLocation(this.environment === "production") : { function: "disabled" },
      requestId: generateRequestId(),
      scope,
      object: cleanObject
    };
  }
  output(level, formattedMessage) {
    const method = CONSOLE_METHODS[level];
    console[method](formattedMessage);
  }
  log(level, message, object) {
    const entry = this.createLogEntry(level, message, object);
    const formattedMessage = formatLogEntry(entry, this.environment);
    this.output(level, formattedMessage);
  }
  info(message, object) {
    this.log("info", message, object);
  }
  warn(message, object) {
    this.log("warn", message, object);
  }
  error(message, object) {
    this.log("error", message, object);
  }
};
var createLogger = (config) => new NextNodeLogger(config);
var logger = createLogger();
export {
  createLogger,
  detectEnvironment,
  detectRuntime,
  generateRequestId,
  getCurrentTimestamp,
  hasCryptoSupport,
  logger,
  parseLocation,
  safeStringify
};
//# sourceMappingURL=@nextnode_logger.js.map
